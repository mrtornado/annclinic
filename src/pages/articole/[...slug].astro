---
import { getCollection, type CollectionEntry } from "astro:content";
import ArticleLayout from "../../layouts/ArticleLayout.astro";

// Server-side rendering pentru dynamic routes
const { slug } = Astro.params;
const articleSlug = Array.isArray(slug) ? slug.join("/") : slug || "";

// Găsim articolul pe baza slug-ului
const articles = await getCollection("articles");
const article = articles.find((a) => a.slug === articleSlug);

// 404 dacă articolul nu există
if (!article) {
  return new Response(null, {
    status: 404,
    statusText: "Articolul nu a fost găsit"
  });
}

// Get related articles based on specialty and tags
const allArticles = await getCollection("articles");
const relatedArticles = allArticles
  .filter(
    (a) =>
      a.slug !== article.slug &&
      (a.data.specialty === article.data.specialty ||
        a.data.tags.some((tag) => article.data.tags.includes(tag)))
  )
  .sort((a, b) => {
    // Prioritize same specialty
    const aSpecialtyMatch = a.data.specialty === article.data.specialty ? 1 : 0;
    const bSpecialtyMatch = b.data.specialty === article.data.specialty ? 1 : 0;

    if (aSpecialtyMatch !== bSpecialtyMatch) {
      return bSpecialtyMatch - aSpecialtyMatch;
    }

    // Then by tag overlap
    const aTagOverlap = a.data.tags.filter((tag) =>
      article.data.tags.includes(tag)
    ).length;
    const bTagOverlap = b.data.tags.filter((tag) =>
      article.data.tags.includes(tag)
    ).length;

    if (aTagOverlap !== bTagOverlap) {
      return bTagOverlap - aTagOverlap;
    }

    // Finally by publish date (newest first)
    return (
      new Date(b.data.publishDate).getTime() -
      new Date(a.data.publishDate).getTime()
    );
  })
  .slice(0, 6); // Limit to 6 related articles
---

<ArticleLayout article={article} relatedArticles={relatedArticles} />
